diff --git a/CMakeLists.txt b/CMakeLists.txt
index f318625e..b86ef63d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,7 +3,7 @@ if (${CMAKE_VERSION} VERSION_GREATER_EQUAL "3.0")
     cmake_policy(SET CMP0042 NEW)
 endif()
 
-project(biorbd VERSION 1.8.4)
+project(biorbd VERSION 1.8.7)
 set(BIORBD_ROOT_FOLDER ${PROJECT_SOURCE_DIR})
 set (BIORBD_NAME_NO_SUFFIX ${PROJECT_NAME})
 set (CMAKE_CXX_STANDARD 11)
diff --git a/binding/biorbd.i.in b/binding/biorbd.i.in
index 4b17b8a9..8c374966 100644
--- a/binding/biorbd.i.in
+++ b/binding/biorbd.i.in
@@ -29,6 +29,11 @@
 %include <std_pair.i>
 namespace std {
 %template(VecStdString) std::vector<std::string>;
+%template(VecStdBool) std::vector<bool>;
+%template(VecInt) std::vector<int>;
+%template(VecVecInt) std::vector<std::vector<int>>;
+%template(VecUnsignedInt) std::vector<unsigned int>;
+%template(VecVecUnsignedInt) std::vector<std::vector<unsigned int>>;
 }
 
 // Includes all neceressary files from the API
@@ -41,5 +46,3 @@ namespace std {
 %include "@CMAKE_SOURCE_DIR@/include/BiorbdModel.h"
 %include "@CMAKE_SOURCE_DIR@/include/ModelReader.h"
 %include "@CMAKE_SOURCE_DIR@/include/ModelWriter.h"
-
-
diff --git a/include/RigidBody/Contacts.h b/include/RigidBody/Contacts.h
index 44d6f30a..adb29ba7 100644
--- a/include/RigidBody/Contacts.h
+++ b/include/RigidBody/Contacts.h
@@ -141,21 +141,67 @@ public:
     utils::String contactName(unsigned int i);
 
     ///
-    /// \brief Return the contraints position in the global reference
+    /// \brief Return a vector with the sorted axis index considered in the rigid contact
+    /// \param contact_idx the index of the rigid contact
+    /// \return A vector with the sorted axis index considered in the rigid contact
+    ///
+    std::vector<int> rigidContactAxisIdx(unsigned int contact_idx) const;
+
+    ///
+    /// \brief Return the constraints position in the global reference
     /// \param Q The generalized coordinates of the joints
     /// \param updateKin Whether the kinematics of the model should be updated from Q
-    /// \return The contraints positions in the global reference
+    /// \return The constraints positions in the global reference
     ///
     std::vector<utils::Vector3d> constraintsInGlobal(
         const GeneralizedCoordinates &Q,
         bool updateKin);
 
     ///
-    /// \brief Return the force acting on the contraint
-    /// \return The force acting on the contraint
+    /// \brief Return the force acting on the constraint
+    /// \return The force acting on the constraint
     ///
     utils::Vector getForce() const;
 
+    ///
+    /// \brief Return the segment idx of the contact in biorbd formalism
+    /// \param idx The index of the contact
+    /// \return segment idx of the contact in biorbd formalism
+    ///
+    int contactSegmentBiorbdId(
+            int  idx) const;
+
+    ///
+    /// \brief Return the index of rigid contacts for a specified segment index
+    /// \param idx The index of the segment
+    /// \return the index of rigid contacts for the specified segment idx
+    ///
+    std::vector<size_t> segmentRigidContactIdx(
+            int segment_idx) const;
+
+    ///
+    /// \brief Get the rigid contacts in a list of spatial vector of dimension 6xNdof
+    /// \param Q The Generalized coordinates
+    /// \param f_contacts the forces applied at the contact points
+    /// \return The rigid contacts
+    ///
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* rigidContactToSpatialVector(
+            const GeneralizedCoordinates& Q,
+            std::vector<utils::Vector> *f_contacts,
+            bool updateKin);
+
+    ///
+    /// \brief Get the rigid contacts in a list of spatial vector of dimension 6xNdof
+    /// \param applicationPoint the position where the force is applied in base coordinate
+    /// \param sorted_axis_index vector of the sorted axis index considered in the rigid contact
+    /// \param f_contact the forces applied at the contact point
+    /// \return The rigid contacts
+    ///
+    utils::SpatialVector computeForceAtOrigin(
+            utils::Vector3d applicationPoint,
+            std::vector<int> sortedAxisIndex,
+            utils::Vector f_contact);
+
     ///
     /// \brief Returns the number of rigid contacts (ignoring the loop constraints)
     /// \return The number of rigid contacts (ignoring the loop constraints)
diff --git a/include/RigidBody/Joints.h b/include/RigidBody/Joints.h
index 2393a444..918b2093 100644
--- a/include/RigidBody/Joints.h
+++ b/include/RigidBody/Joints.h
@@ -144,7 +144,7 @@ public:
     /// \param segmentName The name of the segment
     /// \return The biorbd body identification
     ///
-    int GetBodyBiorbdId(
+    int getBodyBiorbdId(
         const utils::String &segmentName) const;
 
     ///
@@ -152,9 +152,35 @@ public:
     /// \param segmentName The name of the segment
     /// \return The rbdl body identification
     ///
-    int GetBodyRbdlId(
+    int getBodyRbdlId(
         const utils::String &segmentName) const;
 
+    ///
+    /// \brief Return the Biorbd body identification from rbdl
+    /// \param idx The Rbdl body Id
+    /// \return The Biorbd body identification
+    ///
+    int getBodyRbdlIdToBiorbdId(
+        const int idx) const;
+
+    ///
+    /// \brief Return the rbdl idx of subtrees of each segments
+    /// \return the rbdl idx of subtrees of each segments
+    ///
+    std::vector<std::vector<unsigned int> > getDofSubTrees();
+
+protected:
+    ///
+    /// \brief Return the rbdl idx of subtrees of each segments
+    /// \param subTrees the rbdl idx of subtrees of each segments to be filled
+    /// \param idx starting index to explore the subtrees
+    /// \return the rbdl idx of subtrees of each segments starting from the specified index
+    ///
+    std::vector<std::vector<unsigned int> > recursiveDofSubTrees(
+            std::vector<std::vector<unsigned int> >subTrees,
+            unsigned int idx);
+
+public:
     ///
     /// \brief Return the number of generalized torque
     /// \return The number of generalized torque
@@ -287,11 +313,15 @@ protected:
     /// \param f_ext The external forces (it can be a nullptr)
     /// \param Q The generalized coordinates
     /// \param Qdot The generalized velocities
+    /// \param f_contacts The forces applied to the rigid contacts
+    /// \param updateKin If the kinematics of the model should be computed
     ///
     std::vector<RigidBodyDynamics::Math::SpatialVector> * combineExtForceAndSoftContact(
             std::vector<utils::SpatialVector> *f_ext,
+            std::vector<utils::Vector> *f_contacts,
             const rigidbody::GeneralizedCoordinates& Q,
-            const rigidbody::GeneralizedVelocity& QDot);
+            const rigidbody::GeneralizedVelocity& QDot,
+            bool updateKin);
 
     // ---------------------------- //
 public:
@@ -709,6 +739,16 @@ public:
         const GeneralizedCoordinates &Q,
         bool updateKin = true);
 
+    ///
+    /// \brief Get the inverse mass matrix at a given position Q
+    /// \param Q The generalized coordinates
+    /// \param updateKin If the kinematics should be updated
+    /// \return The inverse mass matrix
+    ///
+    utils::Matrix massMatrixInverse(
+        const rigidbody::GeneralizedCoordinates &Q,
+        bool updateKin = true);
+
     ///
     /// \brief Calculate the angular momentum of the center of mass
     /// \param Q The generalized coordinates
@@ -809,25 +849,29 @@ public:
     /// \param QDot The Generalized Velocities
     /// \param QDDot The Generalzed Acceleration
     /// \param f_ext External force acting on the system if there are any
+    /// \param f_contacts The forces applied to the rigid contacts if there are any
     /// \return The Generalized Torques
     ///
-    GeneralizedTorque InverseDynamics(
-        const GeneralizedCoordinates &Q,
+    GeneralizedTorque InverseDynamics(const GeneralizedCoordinates &Q,
         const GeneralizedVelocity &QDot,
         const rigidbody::GeneralizedAcceleration &QDDot,
-        std::vector<utils::SpatialVector>* f_ext = nullptr);
+        std::vector<utils::SpatialVector>* f_ext = nullptr,
+        std::vector<utils::Vector> *f_contacts = nullptr);
 
     ///
     /// \brief Interface to NonLinearEffect
     /// \param Q The Generalized Coordinates
     /// \param QDot The Generalized Velocities
     /// \param f_ext External force acting on the system if there are any
+    /// \param f_contacts The forces applied to the rigid contacts if there are any
     /// \return The Generalized Torques of the bias effects
     ///
     GeneralizedTorque NonLinearEffect(
         const GeneralizedCoordinates &Q,
         const GeneralizedVelocity &QDot,
-        std::vector<utils::SpatialVector>* f_ext = nullptr);
+        std::vector<utils::SpatialVector>* f_ext = nullptr,
+        std::vector<utils::Vector> *f_contacts = nullptr);
+
 
     ///
     /// \brief Interface for the forward dynamics of RBDL
diff --git a/include/RigidBody/Mesh.h b/include/RigidBody/Mesh.h
index c08d0653..bc0bb54a 100644
--- a/include/RigidBody/Mesh.h
+++ b/include/RigidBody/Mesh.h
@@ -99,6 +99,12 @@ public:
     void rotate(
             const utils::RotoTrans& rt);
 
+    ///
+    /// \brief Get the rotation applied to the vertex
+    /// \return The Transformation applied to the mesh wrt the parent
+    ///
+    utils::RotoTrans& getRotation() const;
+
     ///
     /// \brief Scale the vertex wrt to 0, 0, 0. Warnign, this function is
     /// applied when called, meaning that if it is called after rotate, it will
@@ -108,6 +114,12 @@ public:
     void scale(
             const utils::Vector3d& scaler);
 
+    ///
+    /// \brief Get the scaling applied to the vertex wrt to 0, 0, 0.
+    /// \return The scaling applied to the mesh wrt the parent
+    ///
+    utils::Vector3d& getScale() const;
+
     ///
     /// \brief Add a face patch to the mesh
     /// \param face The face patch to add
@@ -160,6 +172,8 @@ protected:
             m_faces; ///< The faces
     std::shared_ptr<utils::Path> m_pathFile; ///< The path to the mesh file
     std::shared_ptr<utils::Vector3d> m_patchColor; ///< The color of faces
+    std::shared_ptr<utils::RotoTrans> m_rotation; ///< The rotation
+    std::shared_ptr<utils::Vector3d> m_scale; ///< The scale
 };
 
 }
diff --git a/include/RigidBody/NodeSegment.h b/include/RigidBody/NodeSegment.h
index bc2ad200..75f92749 100644
--- a/include/RigidBody/NodeSegment.h
+++ b/include/RigidBody/NodeSegment.h
@@ -173,11 +173,13 @@ public:
     ///
     void addAxesToRemove(const utils::String& axis);
 
+#ifndef SWIG
     ///
     /// \brief Add multiple axes to remove
     /// \param axes The multiples axes numbers to remove (x = 0, y = 1 and z = 2)
     ///
     void addAxesToRemove(const std::vector<unsigned int>& axes);
+#endif
 
     ///
     /// \brief Add multiple axes to remove
@@ -189,7 +191,7 @@ public:
     /// \brief Return the axes to removed
     /// \return The axes to removed
     ///
-    utils::String axesToRemove();
+    utils::String axesToRemove() const;
 
     ///
     /// \brief Return the number of axes to remove
diff --git a/src/ModelWriter.cpp b/src/ModelWriter.cpp
index 5e526052..6d0c163e 100644
--- a/src/ModelWriter.cpp
+++ b/src/ModelWriter.cpp
@@ -8,6 +8,7 @@
 #include "Utils/String.h"
 #include "Utils/Path.h"
 #include "Utils/Matrix3d.h"
+#include "Utils/Vector.h"
 #include "RigidBody/IMU.h"
 #include "RigidBody/NodeSegment.h"
 #include "RigidBody/Segment.h"
@@ -77,6 +78,19 @@ void Writer::writeModel(Model & model,
             biorbdModelFile << sep << sep << "meshfile" << sep << model.segment(
                                 i).characteristics().mesh().path().originalPath() <<
                             std::endl;
+            biorbdModelFile << sep << sep << "meshcolor" << sep << model.segment(
+                i).characteristics().mesh().color().transpose() <<
+            std::endl;
+            biorbdModelFile << sep << sep << "meshscale" << sep << model.segment(
+                i).characteristics().mesh().getScale().transpose() <<
+            std::endl;
+
+            biorbdModelFile << sep << sep << "meshrt" << sep << 
+            utils::RotoTrans::toEulerAngles(model.segment(i).characteristics().mesh().getRotation(), 
+            utils::String("xyz")).transpose() <<
+            " xyz " <<
+            model.segment(i).characteristics().mesh().getRotation().trans().transpose() <<
+            std::endl;
         }
         biorbdModelFile << sep << "endsegment" << sep << std::endl;
         biorbdModelFile << std::endl;
diff --git a/src/RigidBody/Contacts.cpp b/src/RigidBody/Contacts.cpp
index 8324dacb..55b68b66 100644
--- a/src/RigidBody/Contacts.cpp
+++ b/src/RigidBody/Contacts.cpp
@@ -10,6 +10,7 @@
 #include "Utils/SpatialVector.h"
 #include "RigidBody/Joints.h"
 #include "RigidBody/NodeSegment.h"
+#include "RigidBody/Segment.h"
 #include "RigidBody/GeneralizedCoordinates.h"
 #include "RigidBody/GeneralizedVelocity.h"
 #include "RigidBody/GeneralizedAcceleration.h"
@@ -170,6 +171,32 @@ utils::String rigidbody::Contacts::contactName(unsigned int i)
     return RigidBodyDynamics::ConstraintSet::name[i];
 }
 
+std::vector<int> rigidbody::Contacts::rigidContactAxisIdx(unsigned int contact_idx) const
+{
+    std::vector<int> list;
+
+    // Assuming that this is also a Joints type (via BiorbdModel)
+    const rigidbody::Joints &model =
+        dynamic_cast<const rigidbody::Joints &>(*this);
+
+    const utils::String& axis = rigidContact(contact_idx).axesToRemove();
+
+    for (unsigned int i=0; i<axis.length(); ++i) {
+
+        if      (axis.tolower()[i] == 'x'){
+            list.push_back(0);
+        }
+        else if (axis.tolower()[i] == 'y'){
+            list.push_back(1);
+        }
+        else if (axis.tolower()[i] == 'z'){
+            list.push_back(2);
+        }
+
+    }
+    return list;
+}
+
 
 std::vector<utils::Vector3d>
 rigidbody::Contacts::constraintsInGlobal(
@@ -352,17 +379,127 @@ utils::Vector rigidbody::Contacts::getForce() const
     return static_cast<utils::Vector>(this->force);
 }
 
+const std::vector<rigidbody::NodeSegment> &rigidbody::Contacts::rigidContacts() const
+{
+    return *m_rigidContacts;
+}
+
+const rigidbody::NodeSegment &rigidbody::Contacts::rigidContact(unsigned int idx) const
+{
+    return (*m_rigidContacts)[idx];
+}
+
 int rigidbody::Contacts::nbRigidContacts() const
 {
     return m_rigidContacts->size();
 }
 
-const std::vector<rigidbody::NodeSegment> &rigidbody::Contacts::rigidContacts() const
+int rigidbody::Contacts::contactSegmentBiorbdId(
+        int idx) const
 {
-    return *m_rigidContacts;
+    utils::Error::check(idx < nbRigidContacts(),
+                                "Idx for rigid contact Segment Id is too high..");
+
+    // Assuming that this is also a joint type (via BiorbdModel)
+    const rigidbody::Joints &model = dynamic_cast<const rigidbody::Joints &>(*this);
+
+    const rigidbody::NodeSegment& c = rigidContact(idx);
+
+    return model.getBodyRbdlIdToBiorbdId(c.parentId());
 }
 
-const rigidbody::NodeSegment &rigidbody::Contacts::rigidContact(unsigned int idx) const
+std::vector<size_t> rigidbody::Contacts::segmentRigidContactIdx(
+        int segment_idx) const
 {
-    return (*m_rigidContacts)[idx];
+    // Output variable
+    std::vector<size_t> indices;
+
+    // On each rigidcontact, verify if it belongs to the segment specified
+    for (int i=0; i<nbRigidContacts(); ++i)
+        {
+        if (contactSegmentBiorbdId(i) == segment_idx) {
+            indices.push_back(i);
+        }
+    }
+
+    return indices;
+}
+
+std::vector<RigidBodyDynamics::Math::SpatialVector>* rigidbody::Contacts::rigidContactToSpatialVector(
+        const GeneralizedCoordinates& Q,
+        std::vector<utils::Vector> *f_contacts,
+        bool updateKin)
+{
+    if (!f_contacts){
+        return nullptr;
+    }
+    if ((*f_contacts).size() == 0){
+        return nullptr;
+    }
+    if (nbRigidContacts() == 0){
+        return nullptr;
+    }
+
+    // Assuming that this is also a joint type (via BiorbdModel)
+    rigidbody::Joints& model = dynamic_cast<rigidbody::Joints&>(*this);
+
+#ifdef BIORBD_USE_CASADI_MATH
+    updateKin = true;
+#else
+    model.UpdateKinematicsCustom(&Q, nullptr, nullptr);
+    updateKin = false;
+#endif
+
+    RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* out = new std::vector<RigidBodyDynamics::Math::SpatialVector>();
+    out->push_back(sp_zero);
+    for (size_t i = 0; i < model.nbSegment(); ++i){
+
+        unsigned int nbRigidContactSegment = segmentRigidContactIdx(i).size();
+        RigidBodyDynamics::Math::SpatialVector tp(0.,0.,0.,0.,0.,0.);
+
+        for (size_t j = 0; j < nbRigidContactSegment; ++j)
+        {
+            // Index of rigid contact
+            unsigned int contact_index = segmentRigidContactIdx(i)[j];
+            // Find the application point of the force
+            utils::Vector3d x = rigidContact(Q, contact_index, updateKin);
+            // Find the list of sorted index of normal enabled in .bioMod
+            std::vector<int> rca_idx = rigidContactAxisIdx(contact_index);
+            // Add the contribution of the force of this point
+            tp += computeForceAtOrigin(x, rca_idx, (*f_contacts)[contact_index]);
+        }
+
+        // Put all the force at zero before the last dof of the segment
+        for (int j = 0; j < static_cast<int>(model.segment(i).nbDof()) - 1; ++j){
+            out->push_back(sp_zero);
+        }
+        // Put all the force on the last dof of the segment
+        out->push_back(tp);
+    }
+    return out;
+}
+
+utils::SpatialVector rigidbody::Contacts::computeForceAtOrigin(
+        utils::Vector3d applicationPoint,
+        std::vector<int> sortedAxisIndex,
+        utils::Vector f_contact)
+{
+
+    utils::Vector3d force(0., 0., 0.);
+
+    for  (size_t j = 0; j < sortedAxisIndex.size(); ++j)
+    {
+        // Fill only if contact normal is enabled in .bioMod
+        // sorted in .BioMod
+        unsigned int cur_axis=sortedAxisIndex[j];
+        force.block(cur_axis, 0, 1, 1) = f_contact.block(j, 0, 1, 1);
+    }
+
+    utils::SpatialVector out(0., 0., 0., 0., 0., 0.);
+    out.block(0, 0, 3, 1) = force.cross(- applicationPoint); // Transport to Origin (Bour's formula)
+    out.block(3, 0, 3, 1) = force;
+
+    return out;
 }
diff --git a/src/RigidBody/IMUs.cpp b/src/RigidBody/IMUs.cpp
index d579e6fe..012f5475 100644
--- a/src/RigidBody/IMUs.cpp
+++ b/src/RigidBody/IMUs.cpp
@@ -120,7 +120,7 @@ rigidbody::IMU rigidbody::IMUs::IMU(
     }
 
     rigidbody::IMU node = IMU(idx);
-    unsigned int id = static_cast<unsigned int>(model.GetBodyBiorbdId(
+    unsigned int id = static_cast<unsigned int>(model.getBodyBiorbdId(
                           node.parent()));
 
     return model.globalJCS(id) * node;
diff --git a/src/RigidBody/Joints.cpp b/src/RigidBody/Joints.cpp
index 3deaf75c..57ab9691 100644
--- a/src/RigidBody/Joints.cpp
+++ b/src/RigidBody/Joints.cpp
@@ -233,7 +233,7 @@ const rigidbody::Segment& rigidbody::Joints::segment(
 const rigidbody::Segment &rigidbody::Joints::segment(
     const utils::String & name) const
 {
-    return segment(static_cast<unsigned int>(GetBodyBiorbdId(name.c_str())));
+    return segment(static_cast<unsigned int>(getBodyBiorbdId(name.c_str())));
 }
 
 const std::vector<rigidbody::Segment>& rigidbody::Joints::segments() const
@@ -308,37 +308,81 @@ const  // a spatialVector per platform
 
 std::vector<RigidBodyDynamics::Math::SpatialVector> * rigidbody::Joints::combineExtForceAndSoftContact(
         std::vector<utils::SpatialVector> *f_ext,
+        std::vector<utils::Vector> *f_contacts,
         const rigidbody::GeneralizedCoordinates& Q,
-        const rigidbody::GeneralizedVelocity& QDot)
+        const rigidbody::GeneralizedVelocity& QDot,
+        bool updateKin
+        )
 {
-    std::vector<RigidBodyDynamics::Math::SpatialVector>* softContacts = dynamic_cast<rigidbody::SoftContacts*>(this)->softContactToSpatialVector(Q, QDot);
-    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl = dispatchedForce(f_ext);
+#ifdef BIORBD_USE_CASADI_MATH
+    updateKin = true;
+#else
+    if (updateKin){
+        UpdateKinematicsCustom(&Q, &QDot);
+    }
+    updateKin = false;
+#endif
 
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* softContacts = dynamic_cast<rigidbody::SoftContacts*>(this)->softContactToSpatialVector(Q, QDot, updateKin);
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl = dispatchedForce(f_ext);
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_contacts_rbdl = dynamic_cast<rigidbody::Contacts*>(this)->rigidContactToSpatialVector(Q, f_contacts, updateKin);
 
-    if (!f_ext_rbdl && !softContacts){
+    if (!f_ext_rbdl && !softContacts && !f_contacts_rbdl){
         // Return a nullptr
         return nullptr;
     }
 
-    if (!f_ext_rbdl){
+    if (!f_ext_rbdl && !f_contacts_rbdl){
         // Return the softContacts (and nullptr if softContacts is nullptr)
         return softContacts;
     }
 
-    if (!softContacts){
+    if (!softContacts && !f_contacts_rbdl){
         // Return the External forces
         return f_ext_rbdl;
     }
 
+    if (!f_ext_rbdl && !softContacts){
+        // Return the contact forces
+        return f_contacts_rbdl;
+    }
+
+    if (!f_contacts_rbdl)
+    {
     for (size_t i=0; i<softContacts->size(); ++i){
         // Combine the external forces with the soft contacts
         (*f_ext_rbdl)[i] += (*softContacts)[i];
     }
+    return f_ext_rbdl;
+    }
+    if (!softContacts)
+    {
+    for (size_t i=0; i<f_contacts_rbdl->size(); ++i){
+        // Combine the external forces with the soft contacts
+        (*f_ext_rbdl)[i] += (*f_contacts_rbdl)[i];
+    }
+    return f_ext_rbdl;
+    }
+    if (!f_ext_rbdl)
+    {
+    for (size_t i=0; i<f_contacts_rbdl->size(); ++i){
+        // Combine the external forces with the soft contacts
+        (*softContacts)[i] += (*f_contacts_rbdl)[i];
+    }
+    return softContacts;
+    }
+    for (size_t i=0; i<f_contacts_rbdl->size(); ++i){
+        // Combine the external forces with the soft contacts
+        (*f_ext_rbdl)[i] += (*softContacts)[i];
+        (*f_ext_rbdl)[i] += (*f_contacts_rbdl)[i];
+    }
+
     delete softContacts;
+    delete f_contacts_rbdl;
     return f_ext_rbdl;
 }
 
-int rigidbody::Joints::GetBodyBiorbdId(
+int rigidbody::Joints::getBodyBiorbdId(
         const utils::String &segmentName) const
 {
     for (int i=0; i<static_cast<int>(m_segments->size()); ++i)
@@ -349,12 +393,96 @@ int rigidbody::Joints::GetBodyBiorbdId(
 }
 
 
-int rigidbody::Joints::GetBodyRbdlId(
+int rigidbody::Joints::getBodyRbdlId(
         const utils::String &segmentName) const
 {
     return GetBodyId(segmentName.c_str());
 }
 
+int rigidbody::Joints::getBodyRbdlIdToBiorbdId(
+        const int idx) const
+{
+    // Assuming that this is also a joint type (via BiorbdModel)
+    const rigidbody::Joints &model = dynamic_cast<const rigidbody::Joints &>(*this);
+    std::string bodyName = model.GetBodyName(idx);
+    return model.getBodyBiorbdId(bodyName);
+}
+
+std::vector<std::vector<unsigned int> > rigidbody::Joints::getDofSubTrees()
+{
+    // initialize subTrees
+    std::vector<std::vector<unsigned int> > subTrees;
+    std::vector<unsigned int> subTree_empty;
+    for (unsigned int j=0; j<this->mu.size(); ++j) {
+        subTrees.push_back(subTree_empty);
+    }
+
+    // Get all dof without parent
+    std::vector<unsigned int> dof_with_no_parent_id;
+    for (unsigned int i=1; i<this->mu.size(); ++i) { // begin at 1 because 0 is its own parent in rbdl.
+      if (this->lambda[i]==0) {
+          dof_with_no_parent_id.push_back(i);
+      }
+    }
+
+    // Get all subtrees of dofs without parents
+    for (unsigned int i=0; i<dof_with_no_parent_id.size(); ++i) {
+        unsigned int dof_id = dof_with_no_parent_id[i];
+
+        // initialize subTrees_temp
+        std::vector<std::vector<unsigned int> > subTrees_temp;
+        for (unsigned int j=0; j<this->mu.size(); ++j) {
+          subTrees_temp.push_back(subTree_empty);
+        }
+
+        std::vector<std::vector<unsigned int> > subTrees_temp_filled = recursiveDofSubTrees(subTrees_temp, dof_id);
+        for (unsigned int j=0; j<subTrees_temp.size(); ++j) {
+            if (subTrees_temp_filled[j].empty()) {
+                continue;
+            }
+            else
+            {
+                subTrees[j].insert(subTrees[j].end(),
+                                     subTrees_temp_filled[j].begin(),
+                                     subTrees_temp_filled[j].end());
+            }
+        }
+
+    }
+
+    subTrees.erase(subTrees.begin());
+
+    return  subTrees;
+}
+
+std::vector<std::vector<unsigned int> > rigidbody::Joints::recursiveDofSubTrees(
+        std::vector<std::vector<unsigned int> >subTrees,
+        unsigned int idx)
+{
+    unsigned int q_index_i = this->mJoints[idx].q_index;
+    subTrees[idx].push_back(q_index_i);
+
+    std::vector<std::vector<unsigned int> > subTrees_filled;
+    subTrees_filled = subTrees;
+
+    std::vector<unsigned int> child_idx = this->mu[idx];
+
+    if (child_idx.size() > 0){
+       for (unsigned int i=0; i<child_idx.size(); ++i) {
+            unsigned int cur_child_id = child_idx[i];
+            subTrees_filled = recursiveDofSubTrees(subTrees_filled, cur_child_id);
+            std::vector<unsigned int> subTree_child = subTrees_filled[cur_child_id];
+
+            subTrees_filled[idx].insert(subTrees_filled[idx].end(),
+                                 subTree_child.begin(),
+                                 subTree_child.end());
+      }
+    }
+
+    return subTrees_filled;
+}
+
+
 std::vector<utils::RotoTrans> rigidbody::Joints::allGlobalJCS(
     const rigidbody::GeneralizedCoordinates &Q)
 {
@@ -392,7 +520,7 @@ utils::RotoTrans rigidbody::Joints::globalJCS(
 utils::RotoTrans rigidbody::Joints::globalJCS(
     const utils::String &name) const
 {
-    return globalJCS(static_cast<unsigned int>(GetBodyBiorbdId(name)));
+    return globalJCS(static_cast<unsigned int>(getBodyBiorbdId(name)));
 }
 
 utils::RotoTrans rigidbody::Joints::globalJCS(
@@ -415,7 +543,7 @@ const
 utils::RotoTrans rigidbody::Joints::localJCS(
     const utils::String &name) const
 {
-    return localJCS(static_cast<unsigned int>(GetBodyBiorbdId(name.c_str())));
+    return localJCS(static_cast<unsigned int>(getBodyBiorbdId(name.c_str())));
 }
 utils::RotoTrans rigidbody::Joints::localJCS(
     const unsigned int idx) const
@@ -671,6 +799,130 @@ utils::Matrix rigidbody::Joints::massMatrix (
     return massMatrix;
 }
 
+utils::Matrix rigidbody::Joints::massMatrixInverse (
+    const rigidbody::GeneralizedCoordinates &Q,
+    bool updateKin)
+{
+    unsigned int i = 0; // for loop purpose
+    unsigned int j = 0; // for loop purpose
+    RigidBodyDynamics::Math::MatrixNd Minv(this->dof_count, this->dof_count);
+    Minv.setZero();
+
+#ifdef BIORBD_USE_CASADI_MATH
+    updateKin = true;
+#endif
+    if (updateKin) {
+        UpdateKinematicsCustom(&Q, nullptr, nullptr);
+    }
+    // First Forward Pass
+    for (i = 1; i < this->mBodies.size(); i++) {
+
+      this->I[i].setSpatialMatrix(this->IA[i]);
+      }
+    // End First Forward Pass
+
+    // set F (n x 6 x n)
+    RigidBodyDynamics::Math::MatrixNd F_i(6, this->dof_count);
+    F_i.setZero();
+    // Fill a vector of matrix (6 x n)
+    std::vector<RigidBodyDynamics::Math::MatrixNd> F;
+    for (i = 1; i < this->mBodies.size(); i++)
+    {
+        F.push_back(F_i);
+    }
+
+    // Backward Pass
+    std::vector<std::vector<unsigned int>> subTrees = getDofSubTrees();
+    for (i = this->mBodies.size() - 1; i > 0; i--)
+    {    
+        unsigned int q_index_i = this->mJoints[i].q_index;
+        const std::vector<unsigned int>& sub_tree = subTrees[q_index_i];
+
+        this->U[i] = this->IA[i] * this->S[i];
+        this->d[i] = this->S[i].dot(this->U[i]);
+
+        Minv(q_index_i, q_index_i) = 1.0 / (this->d[i]);
+
+        for (j = 0; j < sub_tree.size(); j++) {
+              const RigidBodyDynamics::Math::SpatialVector& Ftemp = F[q_index_i].block(0, sub_tree[j], 6, 1);
+              Minv(q_index_i,sub_tree[j]) -= (1.0/this->d[i]) * this->S[i].transpose() * Ftemp;
+        }
+
+        unsigned int lambda = this->lambda[i];
+        unsigned int lambda_q_i = this->mJoints[lambda].q_index;
+        if (lambda != 0) {
+            for (j = 0; j < sub_tree.size(); j++) {
+                F[q_index_i].block(0, sub_tree[j], 6, 1) += this->U[i] * Minv.block(q_index_i, sub_tree[j], 1, 1);
+
+                F[lambda_q_i].block(0, sub_tree[j], 6, 1) += this->X_lambda[i].toMatrixTranspose() * F[q_index_i].block(0, sub_tree[j], 6, 1);
+            }
+
+            RigidBodyDynamics::Math::SpatialMatrix Ia = this->IA[i]
+                - this->U[i]
+                * (this->U[i] / this->d[i]).transpose();
+
+#ifdef BIORBD_USE_CASADI_MATH
+          this->IA[lambda]
+            += this->X_lambda[i].toMatrixTranspose()
+            * Ia * this->X_lambda[i].toMatrix();
+
+#else
+          this->IA[lambda].noalias()
+            += this->X_lambda[i].toMatrixTranspose()
+            * Ia * this->X_lambda[i].toMatrix();
+#endif
+        }
+    }
+    // End Backward Pass
+
+    // Second Forward Pass
+    for (i = 1; i < this->mBodies.size(); i++) {
+      unsigned int q_index_i = this->mJoints[i].q_index;
+      unsigned int lambda = this->lambda[i];
+      unsigned int lambda_q_i = this->mJoints[lambda].q_index;
+
+      RigidBodyDynamics::Math::SpatialTransform X_lambda = this->X_lambda[i];
+
+        if (lambda != 0){
+            // Minv[i,i:] = Dinv[i]* (U[i,:].transpose() * Xmat) * F[lambda,:,i:])
+            for (j = q_index_i; j < this->dof_count; j++) {
+//                RigidBodyDynamics::Math::SpatialVector Ftemp = F[lambda_q_i].block(0, q_index_i, 6, 1);
+                RigidBodyDynamics::Math::SpatialVector Ftemp = F[lambda_q_i].block(0, j, 6, 1);
+                Minv(q_index_i, j) -=
+                        (1.0/this->d[i]) * (this->U[i].transpose() * X_lambda.toMatrix()) * Ftemp;
+            }
+
+        }
+        // F[i,:,i:] = np.outer(S,Minv[i,i:]) // could be simplified (S * M[q_index_i,q_index_i:]^T)
+        for (j = q_index_i; j < this->dof_count; j++) {
+                    F[q_index_i].block(0, j, 6, 1) = this->S[i] * Minv.block(q_index_i, j, 1, 1); // outer product
+        }
+
+
+        if (lambda != 0){
+            //  F[i,:,i:] += Xmat.transpose() * F[lambda,:,i:]
+            for (j = q_index_i; j < this->dof_count; j++) {
+                F[q_index_i].block(0, j, 6, 1) +=
+                        X_lambda.toMatrix() * F[lambda_q_i].block(0, j, 6, 1);
+            }
+
+        }
+    }
+    // End of Second Forward Pass
+    // Fill in full matrix (currently only upper triangular)
+    for (j = 0; j < this->dof_count; j++)
+    {
+        for (i = 0; i < this->dof_count; i++)
+        {
+            if (j < i) {
+                    Minv(i, j) = Minv(j, i);
+            }
+        }
+    }
+
+    return Minv;
+}
+
 utils::Vector3d rigidbody::Joints::CoMdot(
     const rigidbody::GeneralizedCoordinates &Q,
     const rigidbody::GeneralizedVelocity &Qdot,
@@ -1144,10 +1396,11 @@ rigidbody::GeneralizedTorque rigidbody::Joints::InverseDynamics(
     const rigidbody::GeneralizedCoordinates &Q,
     const rigidbody::GeneralizedVelocity &QDot,
     const rigidbody::GeneralizedAcceleration &QDDot,
-    std::vector<utils::SpatialVector>* f_ext)
+    std::vector<utils::SpatialVector>* f_ext,
+    std::vector<utils::Vector> *f_contacts)
 {
     rigidbody::GeneralizedTorque Tau(nbGeneralizedTorque());
-    std::vector<RigidBodyDynamics::Math::SpatialVector> *f_ext_rbdl(combineExtForceAndSoftContact(f_ext, Q, QDot));
+    std::vector<RigidBodyDynamics::Math::SpatialVector> *f_ext_rbdl(combineExtForceAndSoftContact(f_ext, f_contacts, Q, QDot, true));
     RigidBodyDynamics::InverseDynamics(*this, Q, QDot, QDDot, Tau, f_ext_rbdl);
     if (f_ext_rbdl){
         delete f_ext_rbdl;
@@ -1158,10 +1411,11 @@ rigidbody::GeneralizedTorque rigidbody::Joints::InverseDynamics(
 rigidbody::GeneralizedTorque rigidbody::Joints::NonLinearEffect(
     const rigidbody::GeneralizedCoordinates &Q,
     const rigidbody::GeneralizedVelocity &QDot,
-    std::vector<utils::SpatialVector>* f_ext)
+    std::vector<utils::SpatialVector>* f_ext,
+    std::vector<utils::Vector> *f_contacts)
 {
     rigidbody::GeneralizedTorque Tau(*this);
-    std::vector<RigidBodyDynamics::Math::SpatialVector> *f_ext_rbdl(combineExtForceAndSoftContact(f_ext, Q, QDot));
+    std::vector<RigidBodyDynamics::Math::SpatialVector> *f_ext_rbdl(combineExtForceAndSoftContact(f_ext, f_contacts, Q, QDot, true));
     RigidBodyDynamics::NonlinearEffects(*this, Q, QDot, Tau, f_ext_rbdl);
     if (f_ext_rbdl){
         delete f_ext_rbdl;
@@ -1176,11 +1430,11 @@ rigidbody::Joints::ForwardDynamics(
     const rigidbody::GeneralizedTorque &Tau,
     std::vector<utils::SpatialVector>* f_ext)
 {
-#ifdef BIORBD_USE_CASADI_MATH
-    UpdateKinematicsCustom(&Q, &QDot);
-#endif
+
+    bool updateKin = true;
+
     rigidbody::GeneralizedAcceleration QDDot(*this);
-    std::vector<RigidBodyDynamics::Math::SpatialVector> *f_ext_rbdl(combineExtForceAndSoftContact(f_ext, Q, QDot));
+    std::vector<RigidBodyDynamics::Math::SpatialVector> *f_ext_rbdl(combineExtForceAndSoftContact(f_ext, nullptr, Q, QDot, updateKin));
     RigidBodyDynamics::ForwardDynamics(*this, Q, QDot, Tau, QDDot, f_ext_rbdl);
     if (f_ext_rbdl){
         delete f_ext_rbdl;
@@ -1199,11 +1453,12 @@ rigidbody::Joints::ForwardDynamicsConstraintsDirect(
 #ifdef BIORBD_USE_CASADI_MATH
     bool updateKin = true;
 #else
-    bool updateKin = true;  // Put this in parameters?
+    UpdateKinematicsCustom(&Q, &QDot);
+    bool updateKin = false;  // Put this in parameters??
 #endif
 
     rigidbody::GeneralizedAcceleration QDDot(*this);
-    std::vector<RigidBodyDynamics::Math::SpatialVector> *f_ext_rbdl(combineExtForceAndSoftContact(f_ext, Q, QDot));
+    std::vector<RigidBodyDynamics::Math::SpatialVector> *f_ext_rbdl(combineExtForceAndSoftContact(f_ext, nullptr, Q, QDot, updateKin));
     RigidBodyDynamics::ForwardDynamicsConstraintsDirect(*this, Q, QDot, Tau, CS, QDDot, updateKin, f_ext_rbdl);
     if (f_ext_rbdl){
         delete f_ext_rbdl;
diff --git a/src/RigidBody/Markers.cpp b/src/RigidBody/Markers.cpp
index 5e196b78..8235e0c2 100644
--- a/src/RigidBody/Markers.cpp
+++ b/src/RigidBody/Markers.cpp
@@ -399,7 +399,7 @@ const
     unsigned int n = 0;
     for (unsigned int i=0; i<nbMarkers();
             ++i) // Go through all the markers and select the right ones
-        if ((*m_marks)[i].parent().compare(name)) {
+        if (!(*m_marks)[i].parent().compare(name)) {
             ++n;
         }
 
diff --git a/src/RigidBody/Mesh.cpp b/src/RigidBody/Mesh.cpp
index 0d718590..f163d3b2 100644
--- a/src/RigidBody/Mesh.cpp
+++ b/src/RigidBody/Mesh.cpp
@@ -12,7 +12,9 @@ rigidbody::Mesh::Mesh() :
     m_vertex(std::make_shared<std::vector<utils::Vector3d>>()),
     m_faces(std::make_shared<std::vector<rigidbody::MeshFace>>()),
     m_pathFile(std::make_shared<utils::Path>()),
-    m_patchColor(std::make_shared<utils::Vector3d>(0.89, 0.855, 0.788))
+    m_patchColor(std::make_shared<utils::Vector3d>(0.89, 0.855, 0.788)),
+    m_rotation(std::make_shared<utils::RotoTrans>(utils::RotoTrans::Identity())),
+    m_scale(std::make_shared<utils::Vector3d>(1.0, 1.0, 1.0))
 {
 
 }
@@ -22,7 +24,9 @@ rigidbody::Mesh::Mesh(
     m_vertex(std::make_shared<std::vector<utils::Vector3d>>(other)),
     m_faces(std::make_shared<std::vector<rigidbody::MeshFace>>()),
     m_pathFile(std::make_shared<utils::Path>()),
-    m_patchColor(std::make_shared<utils::Vector3d>(0.89, 0.855, 0.788))
+    m_patchColor(std::make_shared<utils::Vector3d>(0.89, 0.855, 0.788)),
+    m_rotation(std::make_shared<utils::RotoTrans>(utils::RotoTrans::Identity())),
+    m_scale(std::make_shared<utils::Vector3d>(1.0, 1.0, 1.0))
 {
 
 }
@@ -33,7 +37,9 @@ rigidbody::Mesh::Mesh(const std::vector<utils::Vector3d>
     m_vertex(std::make_shared<std::vector<utils::Vector3d>>(vertex)),
     m_faces(std::make_shared<std::vector<rigidbody::MeshFace>>(faces)),
     m_pathFile(std::make_shared<utils::Path>()),
-    m_patchColor(std::make_shared<utils::Vector3d>(0.89, 0.855, 0.788))
+    m_patchColor(std::make_shared<utils::Vector3d>(0.89, 0.855, 0.788)),
+    m_rotation(std::make_shared<utils::RotoTrans>(utils::RotoTrans::Identity())),
+    m_scale(std::make_shared<utils::Vector3d>(1.0, 1.0, 1.0))
 {
 
 }
@@ -86,14 +92,21 @@ unsigned int rigidbody::Mesh::nbVertex() const
 void rigidbody::Mesh::rotate(
         const utils::RotoTrans &rt)
 {
+    *m_rotation = rt;
     for (auto& v : *m_vertex){
         v.applyRT(rt);
     }
 }
 
+utils::RotoTrans &rigidbody::Mesh::getRotation() const
+{
+    return *m_rotation;
+}
+
 void rigidbody::Mesh::scale(
         const utils::Vector3d &scaler)
-{
+{   
+    *m_scale = scaler;
     for (auto& v: *m_vertex){
         v(0) *= scaler(0);
         v(1) *= scaler(1);
@@ -101,6 +114,11 @@ void rigidbody::Mesh::scale(
     }
 }
 
+utils::Vector3d &rigidbody::Mesh::getScale() const
+{   
+    return *m_scale;
+}
+
 unsigned int rigidbody::Mesh::nbFaces()
 {
     return static_cast<unsigned int>(m_faces->size());
diff --git a/src/RigidBody/NodeSegment.cpp b/src/RigidBody/NodeSegment.cpp
index 9aaaa84a..dd972c53 100644
--- a/src/RigidBody/NodeSegment.cpp
+++ b/src/RigidBody/NodeSegment.cpp
@@ -212,7 +212,7 @@ void rigidbody::NodeSegment::addAxesToRemove(const
     }
 }
 
-utils::String rigidbody::NodeSegment::axesToRemove()
+utils::String rigidbody::NodeSegment::axesToRemove() const
 {
     utils::String axes;
     if (isAxisRemoved(0)) {
diff --git a/src/RigidBody/RotoTransNodes.cpp b/src/RigidBody/RotoTransNodes.cpp
index da828d77..9bcc7786 100644
--- a/src/RigidBody/RotoTransNodes.cpp
+++ b/src/RigidBody/RotoTransNodes.cpp
@@ -126,7 +126,7 @@ utils::RotoTransNode rigidbody::RotoTransNodes::RT(
     }
 
     utils::RotoTransNode node = RT(idx);
-    unsigned int id = static_cast<unsigned int>(model.GetBodyBiorbdId(
+    unsigned int id = static_cast<unsigned int>(model.getBodyBiorbdId(
                           node.parent()));
 
     return model.globalJCS(id) * node;
diff --git a/src/RigidBody/SoftContacts.cpp b/src/RigidBody/SoftContacts.cpp
index 0f28c921..d708f936 100644
--- a/src/RigidBody/SoftContacts.cpp
+++ b/src/RigidBody/SoftContacts.cpp
@@ -48,6 +48,9 @@ std::vector<RigidBodyDynamics::Math::SpatialVector>* rigidbody::SoftContacts::so
         const rigidbody::GeneralizedVelocity& QDot,
         bool updateKin)
 {
+#ifdef BIORBD_USE_CASADI_MATH
+    updateKin = true;
+#endif
     if (nbSoftContacts() == 0){
         return nullptr;
     }
diff --git a/test/models/cubeWithExternalForces.bioMod b/test/models/cubeWithExternalForces.bioMod
new file mode 100644
index 00000000..92c59cc0
--- /dev/null
+++ b/test/models/cubeWithExternalForces.bioMod
@@ -0,0 +1,51 @@
+version 4
+
+// DEFINITION DU SEGMENTS
+
+// Seg1
+segment Seg1
+    translations	xyz
+    rotations	y
+    rangesQ  -0.70 2.30
+             -10 10
+             -3    3
+             -pi   pi
+    mass 1
+    inertia
+        1 0 0
+        0 1 0
+        0 0 1
+    com 0.1 0.1 0.1
+        mesh 0 -1 -1
+        mesh 0 0 -1
+        mesh 0 0 0
+        mesh 0 -1 0
+        mesh 0 -1 -1
+        mesh 1 -1 -1
+        mesh 1 0 -1
+        mesh 0 0 -1
+        mesh 1 0 -1
+        mesh 1 0 0
+        mesh 0 0 0
+        mesh 1 0 0
+        mesh 1 -1 0
+        mesh 0 -1 0
+        mesh 1 -1 0
+        mesh 1 -1 -1
+	externalforceindex 0
+endsegment
+
+// Contact
+contact    PiedG_1
+    parent    Seg1
+    position    -0.00465    0.15809    0.00611
+    axis    yz
+endcontact
+contact    PiedG_2
+    parent    Seg1
+    position    0.00757    0.01189    -0.01802
+    axis    z
+endcontact
+
+        
+        
diff --git a/test/models/cubeWithRigidContactsExternalForces.bioMod b/test/models/cubeWithRigidContactsExternalForces.bioMod
new file mode 100644
index 00000000..92c59cc0
--- /dev/null
+++ b/test/models/cubeWithRigidContactsExternalForces.bioMod
@@ -0,0 +1,51 @@
+version 4
+
+// DEFINITION DU SEGMENTS
+
+// Seg1
+segment Seg1
+    translations	xyz
+    rotations	y
+    rangesQ  -0.70 2.30
+             -10 10
+             -3    3
+             -pi   pi
+    mass 1
+    inertia
+        1 0 0
+        0 1 0
+        0 0 1
+    com 0.1 0.1 0.1
+        mesh 0 -1 -1
+        mesh 0 0 -1
+        mesh 0 0 0
+        mesh 0 -1 0
+        mesh 0 -1 -1
+        mesh 1 -1 -1
+        mesh 1 0 -1
+        mesh 0 0 -1
+        mesh 1 0 -1
+        mesh 1 0 0
+        mesh 0 0 0
+        mesh 1 0 0
+        mesh 1 -1 0
+        mesh 0 -1 0
+        mesh 1 -1 0
+        mesh 1 -1 -1
+	externalforceindex 0
+endsegment
+
+// Contact
+contact    PiedG_1
+    parent    Seg1
+    position    -0.00465    0.15809    0.00611
+    axis    yz
+endcontact
+contact    PiedG_2
+    parent    Seg1
+    position    0.00757    0.01189    -0.01802
+    axis    z
+endcontact
+
+        
+        
diff --git a/test/models/cubeWithSoftContactsRigidContactsExternalForces.bioMod b/test/models/cubeWithSoftContactsRigidContactsExternalForces.bioMod
new file mode 100644
index 00000000..1f9cd623
--- /dev/null
+++ b/test/models/cubeWithSoftContactsRigidContactsExternalForces.bioMod
@@ -0,0 +1,70 @@
+version 4
+
+// DEFINITION DU SEGMENTS
+
+// Seg1
+segment Seg1
+    translations	xyz
+    rotations	y
+    rangesQ  -0.70 2.30
+             -10 10
+             -3    3
+             -pi   pi
+    mass 1
+    inertia
+        1 0 0
+        0 1 0
+        0 0 1
+    com 0.1 0.1 0.1
+        mesh 0 -1 -1
+        mesh 0 0 -1
+        mesh 0 0 0
+        mesh 0 -1 0
+        mesh 0 -1 -1
+        mesh 1 -1 -1
+        mesh 1 0 -1
+        mesh 0 0 -1
+        mesh 1 0 -1
+        mesh 1 0 0
+        mesh 0 0 0
+        mesh 1 0 0
+        mesh 1 -1 0
+        mesh 0 -1 0
+        mesh 1 -1 0
+        mesh 1 -1 -1
+	externalforceindex 0
+endsegment
+
+// Soft contacts
+    softcontact Contact1
+        parent Seg1
+        type sphere
+        position 2 3 4
+        radius 5
+        stiffness 6
+        damping 7
+    endsoftcontact
+    
+    softcontact Contact2
+        parent Seg1
+        type sphere
+        position 8 9 10
+        radius 11
+        stiffness 12
+        damping 13
+    endsoftcontact
+    
+// Contact
+contact    PiedG_1
+    parent    Seg1
+    position    -0.00465    0.15809    0.00611
+    axis    yz
+endcontact
+contact    PiedG_2
+    parent    Seg1
+    position    0.00757    0.01189    -0.01802
+    axis    z
+endcontact
+
+        
+        
diff --git a/test/testWrapperClass.h b/test/testWrapperClass.h
new file mode 100644
index 00000000..c7b57c5a
--- /dev/null
+++ b/test/testWrapperClass.h
@@ -0,0 +1,34 @@
+#ifndef TEST_WRAPPER_CLASS_H
+#define TEST_WRAPPER_CLASS_H
+
+#include "BiorbdModel.h"
+#include "RigidBody/Joints.h"
+#include "RigidBody/Contacts.h"
+#include "RigidBody/SoftContacts.h"
+
+namespace BIORBD_NAMESPACE
+{
+class WrapperToJointsContactSoftcontact :
+        public rigidbody::Joints
+        ,public rigidbody::Contacts
+        ,public rigidbody::SoftContacts {
+
+public:
+    WrapperToJointsContactSoftcontact(const BIORBD_NAMESPACE::Model& m):
+        rigidbody::Joints(m),
+        rigidbody::Contacts(m),
+        rigidbody::SoftContacts(m)
+    {}
+
+    std::vector<RigidBodyDynamics::Math::SpatialVector> * wrapCombineExtForceAndSoftContact(
+            std::vector<utils::SpatialVector> *f_ext,
+            std::vector<utils::Vector> *f_contacts,
+            const rigidbody::GeneralizedCoordinates& Q,
+            const rigidbody::GeneralizedVelocity& QDot,
+            bool updateKin){
+        return this->Joints::combineExtForceAndSoftContact(f_ext, f_contacts, Q, QDot, updateKin);
+    }
+};
+
+}
+#endif
diff --git a/test/test_rigidbody.cpp b/test/test_rigidbody.cpp
index c9e96a06..a0e873fe 100644
--- a/test/test_rigidbody.cpp
+++ b/test/test_rigidbody.cpp
@@ -2,6 +2,7 @@
 #include <gtest/gtest.h>
 #include <rbdl/rbdl_math.h>
 #include <rbdl/Dynamics.h>
+#include <string.h>
 
 #include "BiorbdModel.h"
 #include "biorbdConfig.h"
@@ -9,6 +10,7 @@
 #include "Utils/Range.h"
 #include "Utils/SpatialVector.h"
 #include "Utils/Matrix3d.h"
+#include "Utils/Matrix.h"
 #include "RigidBody/GeneralizedCoordinates.h"
 #include "RigidBody/GeneralizedVelocity.h"
 #include "RigidBody/GeneralizedAcceleration.h"
@@ -24,6 +26,8 @@
     #include "RigidBody/KalmanReconsIMU.h"
 #endif
 
+#include "testWrapperClass.h"
+
 using namespace BIORBD_NAMESPACE;
 
 static double requiredPrecision(1e-10);
@@ -40,6 +44,8 @@ static std::string modelNoRoot("models/pyomecaman_freeFall.bioMod");
 static std::string modelSimple("models/cube.bioMod");
 
 static std::string modelWithSoftContact("models/cubeWithSoftContacts.bioMod");
+static std::string modelWithRigidContactsExternalForces("models/cubeWithRigidContactsExternalForces.bioMod");
+static std::string modelWithSoftContactRigidContactsExternalForces("models/cubeWithSoftContactsRigidContactsExternalForces.bioMod");
 
 TEST(Gravity, change)
 {
@@ -113,6 +119,135 @@ TEST(Contacts, unitTest)
 
         EXPECT_NEAR(contacts.nbContacts(), 7., requiredPrecision);
     }
+    {
+        Model model(modelPathForGeneralTesting);
+
+        EXPECT_EQ(model.rigidContactAxisIdx(0)[0], 1);
+        EXPECT_EQ(model.rigidContactAxisIdx(0)[1], 2);
+    }
+    {
+        Model model(modelPathForGeneralTesting);
+
+        EXPECT_EQ(model.contactSegmentBiorbdId(0), 7);
+    }
+    {
+        Model model(modelPathForGeneralTesting);
+
+        EXPECT_EQ(model.segmentRigidContactIdx(7)[0], 0);
+        EXPECT_EQ(model.segmentRigidContactIdx(7)[1], 1);
+    }
+}
+
+TEST(Contacts, computeForceAtOrigin)
+{
+    {
+        Model model(modelPathForGeneralTesting);
+
+        utils::Vector force;
+        force = utils::Vector(2);
+        force[0] = 1;
+        force[1] = 2;
+
+        const utils::SpatialVector forceAtOrigin = model.computeForceAtOrigin(utils::Vector3d(1, 1, 1),std::vector<int>({1, 2}),force);
+
+        std::vector<double> forceExpected = {1, -2, 1,
+                                             0, 1, 2};
+        for (unsigned int i = 0; i < 6; ++i)
+        {
+            SCALAR_TO_DOUBLE(f, forceAtOrigin(i));
+            EXPECT_NEAR(f, forceExpected[i], requiredPrecision);
+        }
+    }
+}
+
+TEST(Contacts, rigidContactToSpatialVector)
+{
+    {
+        Model model(modelPathForGeneralTesting);
+
+        rigidbody::GeneralizedCoordinates Q(model);
+        FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2, 0.3,
+                                           -2.01, -3.01, -3.01, 0.1, 0.2, 0.3, 0.4}));
+
+        std::vector<utils::Vector> realAllForces;
+        std::vector<utils::Vector> *allForces;
+        allForces = &realAllForces;
+
+        std::vector<RigidBodyDynamics::Math::SpatialVector>*
+        SpatialVectorAtOriginNULL = model.rigidContactToSpatialVector(Q, allForces, true);
+
+        EXPECT_FALSE(SpatialVectorAtOriginNULL);
+    }
+    {
+        Model model(modelPathForGeneralTesting);
+
+        rigidbody::GeneralizedCoordinates Q(model);
+        FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2, 0.3,
+                                           -2.01, -3.01, -3.01, 0.1, 0.2, 0.3, 0.4}));
+
+        std::vector<utils::Vector> realAllForces;
+        std::vector<utils::Vector> *allForces;
+        allForces = &realAllForces;
+
+        utils::Vector force1;
+        force1 = utils::Vector(2);
+        force1[0] = 1;
+        force1[1] = 2;
+
+        utils::Vector force2;
+        force2 = utils::Vector(1);
+        force2[0] = 3;
+
+        utils::Vector force3;
+        force3 = utils::Vector(2);
+        force3[0] = 4;
+        force3[1] = 5;
+
+        utils::Vector force4;
+        force4 = utils::Vector(1);
+        force4[0] = 6;
+
+        allForces->push_back(force1);
+        allForces->push_back(force2);
+        allForces->push_back(force3);
+        allForces->push_back(force4);
+
+        std::vector<RigidBodyDynamics::Math::SpatialVector>*
+                SpatialVectorAtOrigin = model.rigidContactToSpatialVector(Q, allForces, true);
+
+        RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+        RigidBodyDynamics::Math::SpatialVector sp_dof12(-7.592268755852077, -0.7864099999999999, 0.14995, 0, 1.0, 5.0);
+        RigidBodyDynamics::Math::SpatialVector sp_dof15(-17.952947566495585, 1.72277, -0.5998, 0.0, 4.0, 11.0);
+
+        std::vector<RigidBodyDynamics::Math::SpatialVector> sp_expected;
+
+        sp_expected.push_back(sp_zero); // Dof 0
+        sp_expected.push_back(sp_zero); // Dof 1
+        sp_expected.push_back(sp_zero); // Dof 2
+        sp_expected.push_back(sp_zero); // Dof 3
+        sp_expected.push_back(sp_zero); // Dof 4
+        sp_expected.push_back(sp_zero); // Dof 5
+        sp_expected.push_back(sp_zero); // Dof 6
+        sp_expected.push_back(sp_zero); // Dof 7
+        sp_expected.push_back(sp_zero); // Dof 8
+        sp_expected.push_back(sp_zero); // Dof 9
+        sp_expected.push_back(sp_zero); // Dof 10
+        sp_expected.push_back(sp_zero); // Dof 11
+        sp_expected.push_back(sp_dof12); // Dof 12
+        sp_expected.push_back(sp_zero); // Dof 13
+        sp_expected.push_back(sp_zero); // Dof 14
+        sp_expected.push_back(sp_dof15); // Dof 15
+
+        for (unsigned int i = 0; i < 16; ++i){
+
+            for (unsigned int j = 0; j < 6; ++j)
+                    {
+                        SCALAR_TO_DOUBLE(f_expected, sp_expected[i](j));
+                        SCALAR_TO_DOUBLE(f, (*SpatialVectorAtOrigin)[i](j));
+                        EXPECT_NEAR(f, f_expected, requiredPrecision);
+                    }
+        }
+    }
 }
 
 TEST(Contacts, DeepCopy)
@@ -819,6 +954,417 @@ TEST(Joints, unitTest)
             EXPECT_NEAR(momentum, expectedAngularMomentum[i], requiredPrecision);
         }
     }
+    {
+        Model model(modelPathForGeneralTesting);
+        EXPECT_EQ(model.getBodyRbdlIdToBiorbdId(3),0);
+        EXPECT_EQ(model.getBodyRbdlIdToBiorbdId(4),-1);
+    }
+
+}
+
+
+TEST(Joints, combineExtForceAndSoftContact)
+{
+    {
+        // Only f_contacts
+        Model model(modelPathForGeneralTesting);
+
+        rigidbody::GeneralizedCoordinates Q(model);
+        FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2, 0.3,
+                                           -2.01, -3.01, -3.01, 0.1, 0.2, 0.3, 0.4}));
+
+        rigidbody::GeneralizedVelocity QDot(model);
+        FILL_VECTOR(QDot, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2, 0.3,
+                                           -2.01, -3.01, -3.01, 0.1, 0.2, 0.3, 0.4}));
+
+        std::vector<utils::SpatialVector> *allForces_ext;
+        allForces_ext = nullptr;
+
+        std::vector<utils::Vector> realAllForces;
+        std::vector<utils::Vector> *allForces;
+        allForces = &realAllForces;
+
+        utils::Vector force1;
+        force1 = utils::Vector(2);
+        force1[0] = 1;
+        force1[1] = 2;
+
+        utils::Vector force2;
+        force2 = utils::Vector(1);
+        force2[0] = 3;
+
+        utils::Vector force3;
+        force3 = utils::Vector(2);
+        force3[0] = 4;
+        force3[1] = 5;
+
+        utils::Vector force4;
+        force4 = utils::Vector(1);
+        force4[0] = 6;
+
+        allForces->push_back(force1);
+        allForces->push_back(force2);
+        allForces->push_back(force3);
+        allForces->push_back(force4);
+
+        WrapperToJointsContactSoftcontact wrappedModel(model);
+        std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl(
+                    wrappedModel.wrapCombineExtForceAndSoftContact(allForces_ext, allForces, Q, QDot, true)
+                                                            );
+
+        RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+        RigidBodyDynamics::Math::SpatialVector sp_dof12(-7.592268755852077, -0.7864099999999999, 0.14995, 0, 1.0, 5.0);
+        RigidBodyDynamics::Math::SpatialVector sp_dof15(-17.952947566495585, 1.72277, -0.5998, 0.0, 4.0, 11.0);
+
+        std::vector<RigidBodyDynamics::Math::SpatialVector> sp_expected;
+
+        sp_expected.push_back(sp_zero); // Dof 0
+        sp_expected.push_back(sp_zero); // Dof 1
+        sp_expected.push_back(sp_zero); // Dof 2
+        sp_expected.push_back(sp_zero); // Dof 3
+        sp_expected.push_back(sp_zero); // Dof 4
+        sp_expected.push_back(sp_zero); // Dof 5
+        sp_expected.push_back(sp_zero); // Dof 6
+        sp_expected.push_back(sp_zero); // Dof 7
+        sp_expected.push_back(sp_zero); // Dof 8
+        sp_expected.push_back(sp_zero); // Dof 9
+        sp_expected.push_back(sp_zero); // Dof 10
+        sp_expected.push_back(sp_zero); // Dof 11
+        sp_expected.push_back(sp_dof12); // Dof 12
+        sp_expected.push_back(sp_zero); // Dof 13
+        sp_expected.push_back(sp_zero); // Dof 14
+        sp_expected.push_back(sp_dof15); // Dof 15
+
+        for (unsigned int i = 0; i < 16; ++i){
+
+            for (unsigned int j = 0; j < 6; ++j)
+                    {
+                        SCALAR_TO_DOUBLE(f_expected, sp_expected[i](j));
+                        SCALAR_TO_DOUBLE(f, (*f_ext_rbdl)[i](j));
+                        EXPECT_NEAR(f, f_expected, requiredPrecision);
+                    }
+        }
+    }
+    {
+    // Only soft_contacts
+    Model model(modelWithSoftContact);
+
+    rigidbody::GeneralizedCoordinates Q(model);
+    FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    rigidbody::GeneralizedVelocity QDot(model);
+    FILL_VECTOR(QDot, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    std::vector<utils::SpatialVector> *allForces_ext;
+    allForces_ext = nullptr;
+
+    WrapperToJointsContactSoftcontact wrappedModel(model);
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl(
+                wrappedModel.wrapCombineExtForceAndSoftContact(allForces_ext, nullptr, Q, QDot, true)
+                                                        );
+
+    RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+    RigidBodyDynamics::Math::SpatialVector sp_dof4(185392.9862903644, -249642.95301694548, 238700.3791127471, 74247.2670562476, 102146.62960989607, 49317.07505542255);
+
+    std::vector<RigidBodyDynamics::Math::SpatialVector> sp_expected;
+
+    sp_expected.push_back(sp_zero); // Dof 0
+    sp_expected.push_back(sp_zero); // Dof 1
+    sp_expected.push_back(sp_zero); // Dof 2
+    sp_expected.push_back(sp_zero); // Dof 3
+    sp_expected.push_back(sp_dof4); // Dof 4
+
+    for (unsigned int i = 0; i < 5; ++i){
+
+        for (unsigned int j = 0; j < 6; ++j)
+                {
+                    SCALAR_TO_DOUBLE(f_expected, sp_expected[i](j));
+                    SCALAR_TO_DOUBLE(f, (*f_ext_rbdl)[i](j));
+                    EXPECT_NEAR(f, f_expected, 1e-9);
+                }
+        }
+    }
+    {
+    // Only external forces
+    Model model(modelWithRigidContactsExternalForces);
+
+    rigidbody::GeneralizedCoordinates Q(model);
+    FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    rigidbody::GeneralizedVelocity QDot(model);
+    FILL_VECTOR(QDot, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    std::vector<utils::SpatialVector> realallForces_ext;
+    std::vector<utils::SpatialVector> *allForces_ext;
+    allForces_ext = &realallForces_ext;
+
+    utils::SpatialVector force1(1, 2, 3, 4, 5, 6);
+    allForces_ext->push_back(force1);
+
+    WrapperToJointsContactSoftcontact wrappedModel(model);
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl(
+                wrappedModel.wrapCombineExtForceAndSoftContact(allForces_ext, nullptr, Q, QDot, true)
+                                                        );
+
+    RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+    RigidBodyDynamics::Math::SpatialVector sp_dof4(1, 2, 3, 4, 5, 6);
+
+    std::vector<RigidBodyDynamics::Math::SpatialVector> sp_expected;
+
+    sp_expected.push_back(sp_zero); // Dof 0
+    sp_expected.push_back(sp_zero); // Dof 1
+    sp_expected.push_back(sp_zero); // Dof 2
+    sp_expected.push_back(sp_zero); // Dof 3
+    sp_expected.push_back(sp_dof4); // Dof 4
+
+    for (unsigned int i = 0; i < 5; ++i){
+
+        for (unsigned int j = 0; j < 6; ++j)
+                {
+                    SCALAR_TO_DOUBLE(f_expected, sp_expected[i](j));
+                    SCALAR_TO_DOUBLE(f, (*f_ext_rbdl)[i](j));
+                    EXPECT_NEAR(f, f_expected, requiredPrecision);
+                }
+    }
+    }
+    {
+    // external forces + rigid contacts
+    Model model(modelWithRigidContactsExternalForces);
+
+    rigidbody::GeneralizedCoordinates Q(model);
+    FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    rigidbody::GeneralizedVelocity QDot(model);
+    FILL_VECTOR(QDot, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    std::vector<utils::SpatialVector> realallForces_ext;
+    std::vector<utils::SpatialVector> *allForces_ext;
+    allForces_ext = &realallForces_ext;
+
+    utils::SpatialVector force(1, 2, 3, 4, 5, 6);
+    allForces_ext->push_back(force);
+
+    std::vector<utils::Vector> realAllForcesRigidContact;
+    std::vector<utils::Vector> *allForcesRigidContact;
+    allForcesRigidContact = &realAllForcesRigidContact;
+
+    utils::Vector force1;
+    force1 = utils::Vector(2);
+    force1[0] = 1;
+    force1[1] = 2;
+
+    utils::Vector force2;
+    force2 = utils::Vector(1);
+    force2[0] = 3;
+
+    allForcesRigidContact->push_back(force1);
+    allForcesRigidContact->push_back(force2);
+
+    WrapperToJointsContactSoftcontact wrappedModel(model);
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl(
+                wrappedModel.wrapCombineExtForceAndSoftContact(allForces_ext, allForcesRigidContact, Q, QDot, true)
+                                                        );
+
+    RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+    RigidBodyDynamics::Math::SpatialVector sp_dof4(-10.694693700837254, 12.040834024296124, 0.98598321280716972, 4, 6, 11);
+
+    std::vector<RigidBodyDynamics::Math::SpatialVector> sp_expected;
+
+    sp_expected.push_back(sp_zero); // Dof 0
+    sp_expected.push_back(sp_zero); // Dof 1
+    sp_expected.push_back(sp_zero); // Dof 2
+    sp_expected.push_back(sp_zero); // Dof 3
+    sp_expected.push_back(sp_dof4); // Dof 4
+
+    for (unsigned int i = 0; i < 5; ++i){
+
+        for (unsigned int j = 0; j < 6; ++j)
+                {
+                    SCALAR_TO_DOUBLE(f_expected, sp_expected[i](j));
+                    SCALAR_TO_DOUBLE(f, (*f_ext_rbdl)[i](j));
+                    EXPECT_NEAR(f, f_expected, requiredPrecision);
+                }
+    }
+    }
+    {
+    // SoftContact + rigid contacts
+    Model model(modelWithSoftContactRigidContactsExternalForces);
+
+    rigidbody::GeneralizedCoordinates Q(model);
+    FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    rigidbody::GeneralizedVelocity QDot(model);
+    FILL_VECTOR(QDot, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    std::vector<utils::Vector> realAllForcesRigidContact;
+    std::vector<utils::Vector> *allForcesRigidContact;
+    allForcesRigidContact = &realAllForcesRigidContact;
+
+    utils::Vector force1;
+    force1 = utils::Vector(2);
+    force1[0] = 1;
+    force1[1] = 2;
+
+    utils::Vector force2;
+    force2 = utils::Vector(1);
+    force2[0] = 3;
+
+    allForcesRigidContact->push_back(force1);
+    allForcesRigidContact->push_back(force2);
+
+    WrapperToJointsContactSoftcontact wrappedModel(model);
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl(
+                wrappedModel.wrapCombineExtForceAndSoftContact(nullptr, allForcesRigidContact, Q, QDot, true)
+                                                        );
+
+    RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+    RigidBodyDynamics::Math::SpatialVector sp_dof4(185381.29159666356, -249632.91218292119, 238698.36509595989, 74247.267056247598, 102147.62960989607, 49322.075055422552);
+
+    std::vector<RigidBodyDynamics::Math::SpatialVector> sp_expected;
+
+    sp_expected.push_back(sp_zero); // Dof 0
+    sp_expected.push_back(sp_zero); // Dof 1
+    sp_expected.push_back(sp_zero); // Dof 2
+    sp_expected.push_back(sp_zero); // Dof 3
+    sp_expected.push_back(sp_dof4); // Dof 4
+
+    for (unsigned int i = 0; i < 5; ++i){
+
+        for (unsigned int j = 0; j < 6; ++j)
+                {
+                    SCALAR_TO_DOUBLE(f_expected, sp_expected[i](j));
+                    SCALAR_TO_DOUBLE(f, (*f_ext_rbdl)[i](j));
+                    EXPECT_NEAR(f, f_expected, 1e-9);
+                }
+    }
+    }
+    {
+    // SoftContact + external forces
+    Model model(modelWithSoftContactRigidContactsExternalForces);
+
+    rigidbody::GeneralizedCoordinates Q(model);
+    FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    rigidbody::GeneralizedVelocity QDot(model);
+    FILL_VECTOR(QDot, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    std::vector<utils::SpatialVector> realallForces_ext;
+    std::vector<utils::SpatialVector> *allForces_ext;
+    allForces_ext = &realallForces_ext;
+
+    utils::SpatialVector force(1, 2, 3, 4, 5, 6);
+    allForces_ext->push_back(force);
+
+    WrapperToJointsContactSoftcontact wrappedModel(model);
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl(
+                wrappedModel.wrapCombineExtForceAndSoftContact(allForces_ext, nullptr, Q, QDot, true)
+                                                        );
+
+    RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+    RigidBodyDynamics::Math::SpatialVector sp_dof4(185393.98629036441, -249640.95301694548, 238703.37911274709, 74251.267056247598, 102151.62960989607, 49323.075055422552);
+
+    std::vector<RigidBodyDynamics::Math::SpatialVector> sp_expected;
+
+    sp_expected.push_back(sp_zero); // Dof 0
+    sp_expected.push_back(sp_zero); // Dof 1
+    sp_expected.push_back(sp_zero); // Dof 2
+    sp_expected.push_back(sp_zero); // Dof 3
+    sp_expected.push_back(sp_dof4); // Dof 4
+
+    for (unsigned int i = 0; i < 5; ++i){
+
+        for (unsigned int j = 0; j < 6; ++j)
+                {
+                    SCALAR_TO_DOUBLE(f_expected, sp_expected[i](j));
+                    SCALAR_TO_DOUBLE(f, (*f_ext_rbdl)[i](j));
+                    EXPECT_NEAR(f, f_expected, 1e-9);
+                }
+    }
+    }
+    {
+    // SoftContact + external forces + rigid contacts
+    Model model(modelWithSoftContactRigidContactsExternalForces);
+
+    rigidbody::GeneralizedCoordinates Q(model);
+    FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    rigidbody::GeneralizedVelocity QDot(model);
+    FILL_VECTOR(QDot, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2}));
+
+    std::vector<utils::SpatialVector> realallForces_ext;
+    std::vector<utils::SpatialVector> *allForces_ext;
+    allForces_ext = &realallForces_ext;
+
+    utils::SpatialVector force(1, 2, 3, 4, 5, 6);
+    allForces_ext->push_back(force);
+
+    std::vector<utils::Vector> realAllForcesRigidContact;
+    std::vector<utils::Vector> *allForcesRigidContact;
+    allForcesRigidContact = &realAllForcesRigidContact;
+
+    utils::Vector force1;
+    force1 = utils::Vector(2);
+    force1[0] = 1;
+    force1[1] = 2;
+
+    utils::Vector force2;
+    force2 = utils::Vector(1);
+    force2[0] = 3;
+
+    allForcesRigidContact->push_back(force1);
+    allForcesRigidContact->push_back(force2);
+
+    WrapperToJointsContactSoftcontact wrappedModel(model);
+    std::vector<RigidBodyDynamics::Math::SpatialVector>* f_ext_rbdl(
+                wrappedModel.wrapCombineExtForceAndSoftContact(allForces_ext, allForcesRigidContact, Q, QDot, true)
+                                                        );
+
+    RigidBodyDynamics::Math::SpatialVector sp_zero(0, 0, 0, 0, 0, 0);
+    RigidBodyDynamics::Math::SpatialVector sp_dof4(185382.29159666356, -249630.91218292119, 238701.36509595989, 74251.267056247598, 102152.62960989607, 49328.075055422552);
+
+    std::vector<RigidBodyDynamics::Math::SpatialVector> sp_expected;
+
+    sp_expected.push_back(sp_zero); // Dof 0
+    sp_expected.push_back(sp_zero); // Dof 1
+    sp_expected.push_back(sp_zero); // Dof 2
+    sp_expected.push_back(sp_zero); // Dof 3
+    sp_expected.push_back(sp_dof4); // Dof 4
+
+    for (unsigned int i = 0; i < 5; ++i){
+
+        for (unsigned int j = 0; j < 6; ++j)
+                {
+                    SCALAR_TO_DOUBLE(f_expected, sp_expected[i](j));
+                    SCALAR_TO_DOUBLE(f, (*f_ext_rbdl)[i](j));
+                    EXPECT_NEAR(f, f_expected, 1e-9);
+                }
+    }
+    }
+}
+
+TEST(Joints, massMatrixInverse)
+{
+    {
+        Model model(modelPathForGeneralTesting);
+        rigidbody::GeneralizedCoordinates Q(model);
+        FILL_VECTOR(Q, std::vector<double>({-2.01, -3.01, -3.01, 0.1, 0.2, 0.3,
+                                           -2.01, -3.01, -3.01, 0.1, 0.2, 0.3, 0.4}));
+
+        utils::Matrix M(model.massMatrix(Q));
+        utils::Matrix Minv_num = M.inverse();
+
+        utils::Matrix Minv_symbolic = model.massMatrixInverse(Q);
+
+        for (unsigned int j = 0; j < model.dof_count; j++)
+        {
+            for (unsigned int i = 0; i < model.dof_count; i++)
+            {
+                SCALAR_TO_DOUBLE(Minv_num_ij, Minv_num(i,j));
+                SCALAR_TO_DOUBLE(Minv_symbolic_ij, Minv_symbolic(i,j));
+                EXPECT_NEAR(Minv_num_ij, Minv_symbolic_ij, requiredPrecision);
+            }
+        }
+    }
 }
 
 TEST(Markers, copy)
